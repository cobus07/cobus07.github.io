<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>cobus&#39;s website</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前端程序猿">
<meta property="og:type" content="website">
<meta property="og:title" content="cobus's website">
<meta property="og:url" content="http://17sunny.cn/index.html">
<meta property="og:site_name" content="cobus's website">
<meta property="og:description" content="前端程序猿">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="cobus's website">
<meta name="twitter:description" content="前端程序猿">
  
    <link rel="alternative" href="/atom.xml" title="cobus&#39;s website" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/source/img/photo.jpg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">cobus</a></h1>
		</hgroup>

		
		<p class="header-subtitle">欢迎来到我的小站，希望多多交流~</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>About</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/随笔">随笔</a></li>
				        
							<li><a href="/">关于我</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="google" target="_blank" href="http://17sunny.cn" title="google">google</a>
					        
								<a class="github" target="_blank" href="https://github.com/cobus07" title="github">github</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/cobus07" title="zhihu">zhihu</a>
					        
								<a class="mail" target="_blank" href="mailto:cobus07@163.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/CSS3-性能优化/" style="font-size: 10px;">CSS3 性能优化</a> <a href="/tags/js动画-js-动画/" style="font-size: 10px;">js动画 js 动画</a> <a href="/tags/快速排序-排序/" style="font-size: 10px;">快速排序 排序</a> <a href="/tags/数据结构-算法-排序-js/" style="font-size: 10px;">数据结构 算法 排序 js</a> <a href="/tags/算法-排序/" style="font-size: 10px;">算法 排序</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.ruanyifeng.com">阮一峰</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">哈尔滨理工大学软件工程13级，大二下学期接触前端，正在前端路上填各种坑...</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">cobus</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img src="/source/img/photo.jpg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
			</div>
			<hgroup>
			  <h1 class="header-author">cobus</h1>
			</hgroup>
			
			<p class="header-subtitle">欢迎来到我的小站，希望多多交流~</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
					<li><a href="/">关于我</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="google" target="_blank" href="http://17sunny.cn" title="google">google</a>
			        
						<a class="github" target="_blank" href="https://github.com/cobus07" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/cobus07" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="mailto:cobus07@163.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-高性能CSS3优化" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/03/高性能CSS3优化/" class="article-date">
  	<time datetime="2016-02-03T01:27:17.000Z" itemprop="datePublished">2016-02-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/03/高性能CSS3优化/">高性能CSS3优化</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>注：本文出自腾讯AlloyTeam的元彦。</p>
<p>高性能移动Web相较PC的场景需要考虑的因素也相对更多更复杂，我们总结为以下几点： 流量、功耗与流畅度。 在PC时代我们更多的是考虑体验上的流畅度，而在Mobile端本身丰富的场景下，需要额外关注对用户基站网络流量使用的情况，设备耗电量的情况。</p>
<p>关于流畅度，主要体现在前端动画中，在现有的前端动画体系中，通常有两种模式：JS动画与CSS3动画。 JS动画是通过JS动态改写样式实现动画能力的一种方案，在PC端兼容低端浏览器中不失为一种推荐方案。<br>而在移动端，我们选择性能更优浏览器原生实现方案：CSS3动画。</p>
<p>然而，CSS3动画在移动多终端设备场景下，相比PC会面对更多的性能问题，主要体现在动画的卡顿与闪烁。</p>
<p>目前对提升移动端CSS3动画体验的主要方法有几点：</p>
<h3 id="尽可能多的利用硬件能力，如使用3D变形来开启GPU加速"><a href="#尽可能多的利用硬件能力，如使用3D变形来开启GPU加速" class="headerlink" title="尽可能多的利用硬件能力，如使用3D变形来开启GPU加速"></a>尽可能多的利用硬件能力，如使用3D变形来开启GPU加速</h3><pre><code>-webkit-transform: translate3d(0, 0, 0);
-moz-transform: translate3d(0, 0, 0);
-ms-transform: translate3d(0, 0, 0);
transform: translate3d(0, 0, 0);  
</code></pre><h3 id="如动画过程有闪烁（通常发生在动画开始的时候），可以尝试下面的Hack："><a href="#如动画过程有闪烁（通常发生在动画开始的时候），可以尝试下面的Hack：" class="headerlink" title="如动画过程有闪烁（通常发生在动画开始的时候），可以尝试下面的Hack："></a>如动画过程有闪烁（通常发生在动画开始的时候），可以尝试下面的Hack：</h3><pre><code>-webkit-backface-visibility: hidden;
-moz-backface-visibility: hidden;
-ms-backface-visibility: hidden;
backface-visibility: hidden;

-webkit-perspective: 1000;
-moz-perspective: 1000;
-ms-perspective: 1000;
perspective: 1000;
</code></pre><h3 id="如下面一个元素通过translate3d右移500px的动画流畅度会明显优于使用left属性："><a href="#如下面一个元素通过translate3d右移500px的动画流畅度会明显优于使用left属性：" class="headerlink" title="如下面一个元素通过translate3d右移500px的动画流畅度会明显优于使用left属性："></a>如下面一个元素通过translate3d右移500px的动画流畅度会明显优于使用left属性：</h3><pre><code>#ball-1 {
  transition: -webkit-transform .5s ease;
  -webkit-transform: translate3d(0, 0, 0);
}
#ball-1.slidein {
  -webkit-transform: translate3d(500px, 0, 0);
}


#ball-2 {
  transition: left .5s ease;
  left: 0;
}
#ball-2.slidein {
  left: 500px;
}
</code></pre><p>注：3D变形会消耗更多的内存与功耗，应确实有性能问题时才去使用它，兼在权衡</p>
<h3 id="尽可能少的使用box-shadows与gradients"><a href="#尽可能少的使用box-shadows与gradients" class="headerlink" title="尽可能少的使用box-shadows与gradients"></a>尽可能少的使用box-shadows与gradients</h3><p>box-shadows与gradients往往都是页面的性能杀手，尤其是在一个元素同时都使用了它们，所以拥抱扁平化设计吧。</p>
<p>###尽可能的让动画元素不在文档流中，以减少重排</p>
<pre><code>position: fixed;  
position: absolute;  
</code></pre><h3 id="优化-DOM-layout-性能"><a href="#优化-DOM-layout-性能" class="headerlink" title="优化 DOM layout 性能"></a>优化 DOM layout 性能</h3><p>我们从实例开始描述这个主题：</p>
<pre><code>var newWidth = aDiv.offsetWidth + 10;  
aDiv.style.width = newWidth + &apos;px&apos;;  
var newHeight = aDiv.offsetHeight + 10;  
aDiv.style.height = newHeight + &apos;px&apos;;

var newWidth = aDiv.offsetWidth + 10;  
var newHeight = aDiv.offsetHeight + 10;  
aDiv.style.width = newWidth + &apos;px&apos;;  
aDiv.style.height = newHeight + &apos;px&apos;;
</code></pre><p>这是两段能力上完全等同的代码，显式的差异正如我们所见，只有执行顺序的区别。但真是如此吗？下面是加了说明注释的代码版本，很好的阐述了其中的进一步差异：</p>
<pre><code>// 触发两次 layout
var newWidth = aDiv.offsetWidth + 10;   // Read  
aDiv.style.width = newWidth + &apos;px&apos;;     // Write  
var newHeight = aDiv.offsetHeight + 10; // Read  
aDiv.style.height = newHeight + &apos;px&apos;;   // Write

// 只触发一次 layout
var newWidth = aDiv.offsetWidth + 10;   // Read  
var newHeight = aDiv.offsetHeight + 10; // Read  
aDiv.style.width = newWidth + &apos;px&apos;;     // Write  
aDiv.style.height = newHeight + &apos;px&apos;;   // Write
</code></pre><p>从注释中可找到规律，连续的读取offsetWidth/Height属性与连续的设置width/height属性，相比分别读取设置单个属性可少触发一次layout。</p>
<p>从结论看似乎与执行队列有关，没错，这是浏览器的优化策略。所有可触发layout的操作都会被暂时放入 layout-queue 中，等到必须更新的时候，再计算整个队列中所有操作影响的结果，如此就可只进行一次的layout，从而提升性能。</p>
<p>关键一，可触发layout的操作，哪些操作下会layout的更新（也称为reflow或者relayout）？</p>
<p>我们从浏览器的源码实现入手，以开源Webkit/Blink为例， 对layout的更新，Webkit 主要通过 Document::updateLayout 与 Document::updateLayoutIgnorePendingStylesheets 两个方法：</p>
<pre><code>void Document::updateLayout()  
{
    ASSERT(isMainThread());

    FrameView* frameView = view();
    if (frameView &amp;&amp; frameView-&gt;isInLayout()) {
        ASSERT_NOT_REACHED();
        return;
    }

    if (Element* oe = ownerElement())
        oe-&gt;document()-&gt;updateLayout();

    updateStyleIfNeeded();

    StackStats::LayoutCheckPoint layoutCheckPoint;

    if (frameView &amp;&amp; renderer() &amp;&amp; (frameView-&gt;layoutPending() || renderer()-&gt;needsLayout()))
        frameView-&gt;layout();

    if (m_focusedNode &amp;&amp; !m_didPostCheckFocusedNodeTask) {
        postTask(CheckFocusedNodeTask::create());
        m_didPostCheckFocusedNodeTask = true;
    }
}


void Document::updateLayoutIgnorePendingStylesheets()  
{
    bool oldIgnore = m_ignorePendingStylesheets;

    if (!haveStylesheetsLoaded()) {
        m_ignorePendingStylesheets = true;

        HTMLElement* bodyElement = body();
        if (bodyElement &amp;&amp; !bodyElement-&gt;renderer() &amp;&amp; m_pendingSheetLayout == NoLayoutWithPendingSheets) {
            m_pendingSheetLayout = DidLayoutWithPendingSheets;
            styleResolverChanged(RecalcStyleImmediately);
        } else if (m_hasNodesWithPlaceholderStyle)
            recalcStyle(Force);
    }

    updateLayout();

    m_ignorePendingStylesheets = oldIgnore;
}
</code></pre><p>从 updateLayoutIgnorePendingStylesheets 方法的内部实现可知，其也是对 updateLayout 方法的扩展，并且在现有的 layout 更新模式中，大部分场景都是调用 updateLayoutIgnorePendingStylesheets 来进行layout的更新。</p>
<p>搜索 Webkit 实现中调用 updateLayoutIgnorePendingStylesheets 方法的代码, 得到以下可导致触发 layout 的操作：</p>
<p>Element: clientHeight, clientLeft, clientTop, clientWidth, focus(), getBoundingClientRect(), getClientRects(), innerText, offsetHeight, offsetLeft, offsetParent, offsetTop, offsetWidth, outerText, scrollByLines(), scrollByPages(), scrollHeight, scrollIntoView(), scrollIntoViewIfNeeded(), scrollLeft, scrollTop, scrollWidth</p>
<p>Frame, HTMLImageElement: height, width</p>
<p>Range: getBoundingClientRect(), getClientRects()</p>
<p>SVGLocatable: computeCTM(), getBBox()</p>
<p>SVGTextContent: getCharNumAtPosition(), getComputedTextLength(), getEndPositionOfChar(), getExtentOfChar(), getNumberOfChars(), getRotationOfChar(), getStartPositionOfChar(), getSubStringLength(), selectSubString()</p>
<p>SVGUse: instanceRoot</p>
<p>window: getComputedStyle(), scrollBy(), scrollTo(), scrollX, scrollY, webkitConvertPointFromNodeToPage(), webkitConvertPointFromPageToNode()</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS3-性能优化/">CSS3 性能优化</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-heapSort" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/11/heapSort/" class="article-date">
  	<time datetime="2016-01-11T05:43:41.000Z" itemprop="datePublished">2016-01-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/11/heapSort/">堆排序及代码实现</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>堆排序是是选择排序的一种，分为大根堆和小根堆两种，都是完全二叉树。大根堆要求子节点的值不大于父节点的值，所以堆顶的值一定是最大的，小根堆就和大根堆相反，自己的的值不小于父节点，堆顶的值一定是最小的。<br>因此根据大根堆或者小根堆的性质就可以循环的从最后一个值开始与堆顶的值进行调换，调换之后再对从倒数第二个开始向前的所有值进行调整堆，把堆顶的值放到倒数第二个的位置，依此类推，最后的数组就会变成一个有序的数组。<br>根据完全二叉树的定义可以知道，一个完全二叉树的左右子节点的键值分别是 父节点键值<em>2 和 父节点键值</em>2+1 ，但是由于数组的下标是从0开始的，所以以此数组构成的完全二叉树的左右子节点的下标分别是 父节点的下标<em>2+1 与 父节点的下标</em>2+2。<br>下面是JS的大根堆排序实现：<br>    javascript</p>
<pre><code>    rray.prototype.heapAdjust=function(i,j){
        var  nChild;
        for(;2*i+1&lt;j;i=nChild){
                //先找到左部子节点的下标，并把它先赋给nChild
                nChild=2*i+1;
                //如果右部子节点存在并且大于左部,
                子节点的值，那么就把nChild代表的值变成右部子节点的下标
                if(nChild&lt;j-1  &amp;&amp;  this[nChild+1]&gt;this[nChild])++nChild;
                //如果最大子节点的值大于父节点的值，那么就把这个子节点的值与父节点进行调换
                if(this[i]&lt;this[nChild]){
                        var  temp=this[i];
                        this[i]=this[nChild];
                        this[nChild]=temp;
                }else{
                        break;
                }
        }
}
Array.prototype.heapsort=function(){
        //首先要构建一个初始的无序大根堆
        for(i=this.length/2-1;i&gt;=0;i--)
                this.heapAdjust(i,this.length);
        //然后进行堆调整，每次都把堆顶放到后面
        for(i=this.length-1;i&gt;0;i--){
                var  temp=this[i];
                this[i]=this[0];
                this[0]=temp;
                this.heapAdjust(0,i);
        }
}
</code></pre><p>下面是一个上面代码的简单调用：</p>
<pre><code>javascript

var  a=new  Array();
[].push.apply(a,[56,23,89,41,27,63,9,6,125,214]);
a.heapSort();
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法-排序/">算法 排序</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-sort" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/10/sort/" class="article-date">
  	<time datetime="2015-11-10T12:46:37.000Z" itemprop="datePublished">2015-11-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/10/sort/">常见的排序算法(转载)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>冒泡排序（bubble sort）O（n^2）</p>
<p>鸡尾酒排序（Cocktail sort，双向的冒泡排序）—O（n^2）</p>
<p>插入排序（insertion sort）O（n^2）</p>
<p>桶排序（bucket sort）O（n）;需要O（k）额外空间</p>
<p>计数排序（counting sort） O（n+k）;需要O（n+k）额外空间</p>
<p>合并排序（merge sort） O（nlog n）;需要O（n）额外空间</p>
<p>原地合并排序 O（n^2）</p>
<p>二叉排序树排序（Binarytree sort）—O（nlog n）</p>
<p>期望时间；O（n^2）最坏时间；需要O（n）额外空间</p>
<p>鸽巢排序（Pigeonhole sort） O（n+k）;需要O（k）额外空间</p>
<p>基数排序（radix sort） O（n·k）; 需要O（n）额外空间</p>
<p>Gnome 排序O（n^2）</p>
<p>图书馆排序O（nlog n）with high probability，需要（1+ε）n 额外空间</p>
<p>不稳定的<br>选择排序（selection sort）O（n^2）</p>
<p>希尔排序（shell sort）O（nlog n）如果使用最佳的现在版本</p>
<p>组合排序O（nlog n）</p>
<p>堆排序（heap sort）O（nlog n）</p>
<p>平滑排序O（nlog n）</p>
<p>快速排序（quick sort）O（nlog n）期望时间，O（n^2）最坏情况；</p>
<p> 对于大的、乱数列表一般相信是最快的已知排序</p>
<p>Intro sort O（nlog n）</p>
<p>Patience sorting O（nlog n+ k）最坏情况时间，需要 额外的O（n+ k）空间，也需要找到最长的递增子串行（longestincreasingsubsequence）</p>
<p>不实用的</p>
<p>Bogo排序O（n× n!）期望时间，无穷的最坏情况。</p>
<p>Stupid sortO（n^3）; 递归版本需要O（n^2）额外存储器</p>
<p>珠排序（Bead sort） O（n）or O（√n），但需要特别的硬件</p>
<p>Pancake sortingO（n），但需要特别的硬件</p>
<p>stooge sort O（n^2.7）很漂亮但是很耗时</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构-算法-排序-js/">数据结构 算法 排序 js</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-quicksort" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/02/quicksort/" class="article-date">
  	<time datetime="2015-11-02T05:22:02.000Z" itemprop="datePublished">2015-11-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/02/quicksort/">快排及代码实现</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="快速排序（Quicksort）是对冒泡排序的一种改进。"><a href="#快速排序（Quicksort）是对冒泡排序的一种改进。" class="headerlink" title="快速排序（Quicksort）是对冒泡排序的一种改进。"></a>快速排序（Quicksort）是对冒泡排序的一种改进。</h3><p>快速排序的基本思想就是首先把整个数组分成两部分，其中一部分比另外一部分中所有的值都要大，然后再把这两部分分别按照这个方法再分成一大一小两部分，一直递归下去直到每部分只有一个值，这样就能使整个数组的数值有序排列。</p>
<p>设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。</p>
<h3 id="主要实现方法"><a href="#主要实现方法" class="headerlink" title="主要实现方法:"></a>主要实现方法:</h3><p>1.设置两个变量i、j，排序开始的时候：i=0，j=N-1；<br>2.以第一个数组元素作为关键数据，赋值给key，即key=A[0]；<br>3.从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；<br>4.从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；<br>5.重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</p>
<p>快速排序<br>JavaScript实现:</p>
<pre><code>function  qs(array){
        function  qsort(nowi,nowj){
                if(nowj&gt;nowi){
                        var  i=nowi,j=nowj,key=array[nowi];
                        while(j&gt;i){
                                for(;j&gt;i;j--){
                                        if(array[j]&lt;key){
                                                array[i]=array[j];
                                                i++;
                                                break;
                                        }
                                }
                                for(;j&gt;i;i++){
                                        if(array[i]&gt;key){
                                                array[j]=array[i];
                                                j--;
                                                break;
                                        }
                                }    
                        }
                        array[i]=key;
                        qsort(0,i);
                        qsort(i+1,nowj);
                } 
        }
        qsort(0,array.length-1);
        return  array;
}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/快速排序-排序/">快速排序 排序</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-requestAnimationFrame" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/03/requestAnimationFrame/" class="article-date">
  	<time datetime="2015-10-03T11:28:17.000Z" itemprop="datePublished">2015-10-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/03/requestAnimationFrame/">requestAnimationFrame 的使用与优化</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>HTML5/CSS3时代，我们要在web里做动画选择其实已经很多了:</p>
<p>你可以用CSS3的animattion+keyframes;</p>
<p>你也可以用css3的transition;</p>
<p>你还可以用通过在canvas上作图来实现动画，</p>
<p>也可以借助jQuery动画相关的API方便地实现;</p>
<p>当然最原始的你还可以使用window.setTimout()或者window.setInterval()通过不断更新元素的状态位置等来实现动画，前提是画面的更新频率要达到每秒60次才能让肉眼看到流畅的动画效果。</p>
<p>现在又多了一种实现动画的方案，那就是还在草案当中的window.requestAnimationFrame()方法。</p>
<h3 id="初识requestAnimationFrame"><a href="#初识requestAnimationFrame" class="headerlink" title="初识requestAnimationFrame"></a><em>初识requestAnimationFrame</em></h3><p>MDN上对其给出的诠释：</p>
<p>The window.requestAnimationFrame() method tells the browser that you wish to perform an animation and requests that the browser call a specified function to update an animation before the next repaint. The method takes as an argument a callback to be invoked before the repaint.</p>
<p>window.requestAnimationFrame() 将告知浏览器你马上要开始动画效果了，后者需要在下次动画前调用相应方法来更新画面。这个方法就是传递给window.requestAnimationFrame()的回调函数。</p>
<p>也可这个方法原理其实也就跟setTimeout/setInterval差不多，通过递归调用同一方法来不断更新画面以达到动起来的效果，但它优于setTimeout/setInterval的地方在于它是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a><em>基本语法</em></h3><p>可以直接调用，也可以通过window来调用，接收一个函数作为回调，返回一个ID值，通过把这个ID值传给window.cancelAnimationFrame()可以取消该次动画。</p>
<p>requestAnimationFrame(callback)//callback为回调函数</p>
<p>一个简单的例子</p>
<p>模拟一个进度条动画，初始div宽度为1px,在step函数中将进度加1然后再更新到div宽度上，在进度达到100之前，一直重复这一过程。</p>
<pre><code>&lt;div id=&quot;test&quot; style=&quot;width:1px;height:17px;background:#0f0;&quot;&gt;0%&lt;/div&gt;
&lt;input type=&quot;button&quot; value=&quot;Run&quot; id=&quot;run&quot;/&gt;

window.requestAnimationFrame = window.requestAnimationFrame || window.
mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
var start = null;
var ele = document.getElementById(&quot;test&quot;);
var progress = 0;

function step(timestamp) {
    progress += 1;
    ele.style.width = progress + &quot;%&quot;;
    ele.innerHTML=progress + &quot;%&quot;;
    if (progress &lt; 100) {
        requestAnimationFrame(step);
    }
}
requestAnimationFrame(step);
document.getElementById(&quot;run&quot;).addEventListener(&quot;click&quot;, function() {
    ele.style.width = &quot;1px&quot;;
    progress = 0;
    requestAnimationFrame(step);
}, false);
</code></pre><h3 id="浏览器支持情况"><a href="#浏览器支持情况" class="headerlink" title="浏览器支持情况"></a><em>浏览器支持情况</em></h3><p>*chrome:31+</p>
<p>*firefox:26+</p>
<p>*ie:10+</p>
<p>*opera:19+</p>
<p>*safari:6+</p>
<h3 id="Polyfill"><a href="#Polyfill" class="headerlink" title="Polyfill"></a><em>Polyfill</em></h3><p>Polyfill就是垫片，按发明这个词的人的原话来说，它就是一段这样的代码,</p>
<p>####让浏览器原生地支持我们期望使用的一些API。</p>
<p>就比如这里的requestAnimationFrame，在看到了上面的浏览器支持情况后，你就知道了比上面列出的浏览器版本老的就不支持该方法，但为了让代码能够有更好的浏览器兼容性在老机器上也能运行不报错，我们可以写一些代码让浏览器在不支持requestAnimationFrame的情况下使用window.setTimeout()，这是一种回退（fallback）到过去的方法。</p>
<p>这样一来，就可以通俗一点的理解polyfill了，它就是备胎。</p>
<p>下面是由Paul Irish及其他贡献者放在GitHub Gist上的代码片段，用于在浏览器不支持requestAnimationFrame情况下的回退，回退到使用setTmeout的情况。当然，如果你确定代码是工作在现代浏览器中，下面的代码是不必的。</p>
<pre><code>(function() {
    var lastTime = 0;
    var vendors = [&apos;ms&apos;, &apos;moz&apos;, &apos;webkit&apos;, &apos;o&apos;];
    for (var x = 0; x &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x] + &apos;RequestAnimationFrame&apos;];
        window.cancelAnimationFrame = window[vendors[x] + &apos;CancelAnimationFrame&apos;] || window[vendors[x] + &apos;CancelRequestAnimationFrame&apos;];
    }
    if (!window.requestAnimationFrame) window.requestAnimationFrame = function(callback, element) {
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = window.setTimeout(function() {
            callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
    };
    if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function(id) {
        clearTimeout(id);
    };
}());
</code></pre><p>上面代码作用有二，</p>
<p>1.是把各浏览器前缀进行统一<br>2.是在浏览器没有requestAnimationFrame方法时将其指向setTimeout方法</p>
<p>提到备胎代码呢，这里多说一句，在CSS代码中，我们也经常使用这种回退的技巧，即对同一条CSS规则，编写多条以不同浏览器前缀开头代码，或者编写一条备用样式。</p>
<p>下面是一个CSS中的备胎代码的例子：</p>
<pre><code>div {
    background: rgb(0, 0, 0); /* fallback */
    background: rgba(0, 0, 0, 0.5);
}
</code></pre><p>代码中设置div背景为黑色带50%的透明度，但IE9-的浏览器是不支持rbga格式的颜色的，所以浏览器会回退到上一条CSS规则应用rgb颜色。</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a><em>Reference</em></h3><ol>
<li><p>article about rAF from css tricks: <a href="http://css-tricks.com/using-requestanimationframe/" target="_blank" rel="external">http://css-tricks.com/using-requestanimationframe/</a></p>
</li>
<li><p>article about rAF from Paul Irish:<a href="http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/" target="_blank" rel="external">http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/</a></p>
</li>
<li><p>what is polyfill <a href="http://remysharp.com/2010/10/08/what-is-a-polyfill/" target="_blank" rel="external">http://remysharp.com/2010/10/08/what-is-a-polyfill/</a></p>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js动画-js-动画/">js动画 js 动画</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 cobus
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: undefined,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: undefined
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>